**TITLE, 테트리스**

**CONTENT.**  
[설계](#설계)  
[마주한 에러, 해결방법 찾는 과정](#문제해결)

#

#### `설계`

**1. 플레이어 만들기**  
Table > tr(row) > td(column) 이용  
Node.childNodes; 리턴값 nodelist(forEach method 이용할 수 있음)

###

**2. 블록**

- 블록 데이터 저장은 어떤 타입으로? `Map VS Object -> Object`

  - 왜?

    - 요소접근성 좋음 \*\*
    - key-value 한번에 할당해 가독성 좋음
    - 순서보장 필요없음

  - 객체 사이즈는 Object.keys(obj).length 이용

> Map vs Object
>
> - Map: 순서보장, key-value 개수 구하기 쉬움, 요소접근성 낮음
> - Object: 개수 구하기 어렵, 요소접근성 높음, 가독성

###

**3. 상태관리**

- 필요성을 느낀 이유?  
  블록 좌표를 화면에 렌더링한 뒤, 주어진 플레이어 안에서만 움직일 수 있다. 벗어난 곳이라면, 이전으로 돌아와야한다.
- 어떻게 할건가?  
  그러기 위해선 임시값`tempBlock`을 움직이고, 움직인 값이 플레이어 안일때만 원본`originBlock`에 업데이트하자.

###

**4. 렌더링**
주어진 플레이어 안에서만 움직일 수 있도록, 렌더링 함수를 짜야한다. 어떻게 하지?

- 일단, 발생하는 케이스 분류해보자.
  - 움직인 결과가 플레이어 안 -> `originBlock` 업데이트
  - 움직인 결과가 플레이어 밖 -> 업데이트 x, `tempBlock`은 `originBlock`이용해, 이전값으로 변환
    - `height`를 벗어난 경우
    - `width`를 벗어난 경우

###

**5. 블록 고정**

- 블록 고정해야하는 케이스

  - 맨 밑줄에 닿는 경우
  - 고정된 블록에 닿는 경우

> 공통점 : `height`만 고려하면 됨

- 블록에 바인딩된 이벤트
  - 키보드 조작(수동)
    - 좌, 우 -> `width`
    - 아래 -> `height`
  - 타이머함수(자동) `height`

렌더링 함수에 키보드 조작 키를 인자로 받아,
이동한 값이 플레이어 안이 아닐 경우,  
눌린 키가 `ArrowDown`일때만 블록고정함수`fixBlock`를 호출한다.

#

#### `문제해결`

문제를 발견했을 때, 마주한 문제를 정의하고, 또, 어떻게 해결해야할지 여기에 적으면서 해결법을 찾았습니다.  
그래서 잘 정돈된 글이 아님을 미리 밝힙니다.  

**1. 모듈 연결**  
 **문제정의**: let 이지만 import하면 const로 작동해 에러 발생.  
 import하면 const로 작동하는 게 [일반적](https://infoscis.github.io/2018/02/27/ecmascript-6-encapsulating-code-with-modules/)

> 변수 값을 바꾸는 메서드를 구현해서 이용하기

#

**2. 타이머 함수**

**문제정의**: 고정한 블록과 새로 만들어진 블록의 종류가 같을 경우, 고정한 블록의 kind 클래스가 삭제돼, 화면에서 사라진다.

- 블록의 종류가 같을 경우, 이전 값의 kind 클래스가 삭제된다? 왜 그런현상이 생기지?  
  블록 고정(blockStatue : moving -> fix) -> makeBlock -> renderBlcok -> 정상작동할 경우만, moving 붙음.
  - 블록 고정 될 때, kind가 삭제되는 케이스밖에 없는데... controlClass가 문제인가 ?
- controlClass 이후, fix 클래스 검사 -> moving 클래스가 안지워짐  
  (즉, moving & fix 함께 있는 구간있음 -> 렌더에서 moving 삭제할 때, 흔적지울 때 지워지는 것 \*\*)

`solution`  
controlClass > ...deleteElem || deleteElem, 문자열일 때도 ...연산이 작동한다는 걸 간과 !
...연산에서 문자열, 배열을 함께 처리할 수 있는 방법은 뭐가 있을까? 현재는 typeof로 타입체크해서 케이스분류함.

`study` ...연산이 구현된 방법 찾아보기 \*\*

#

**3. 호출스케줄링**  
 **문제정의**: 스페이스를 누른 후(속도를 빠르게 구현), 새블록을 만들어 스피드바인딩 함수를 호출할 때, 속도는 동일하지만 동작 반응 속도가 점점 빨라진다.

일단, 문제로 여겨지는 함수 수행 이후 흐름을 정리해보자.

##### 스페이스 클릭 이후 함수 수행 흐름

10ms 간격으로 move함수를 호출 -> 좌표값을 더해, 렌더함수호출 -> 유효한 좌표값인지 체크 ? 렌더 : 고정 -> 새블록생성 함수 호출

1. move함수 이후에 일어나는 일어나는 일도 지연 간격에 포함된다. 즉, 10ms 보다 함수수행 시간이 길어서 에러나는 거 아닐까 --> 새블록 생성해서 현재 interval 삭제하고 다시 스피드를 바인딩하는데, 다음 블록 스피드에 영향을 왜 줘?

2. 스페이스를 누른 횟수만큼 빨라짐. 원래 1칸씩 내려왔다면, 스페이스 1번 누른 후엔 2칸씩 내려옴 --> 실제로 move가 2번 호출됨.    
  
**해결** setInterval의 timerId을 적절한 곳에서 지우지 못했음

**새로운 문제**  
이제 속도는 일정한데, 중간에 블록이 fix 해버림 -> 지연간격 포함이 문제인거 같은데?  
**해결**  
setTimeout 2개로 구현해 지연간격 보장

```javascript
/* setInterval은 간격을 보장해주지 않음 */
timerId = setInterval(() => moveBlock("height", 1, "ArrowDown"), speed);

/* setTimeout으로 간격보장해주는 setInterval 구현 */
timerId = setTimeout(function repeat() {
  moveBlock("height", 1, "ArrowDown");
  timerId = setTimeout(repeat, speed);
}, speed);
```

[참고:ko.javascript](www.ko.javascript.info)
